"""
Tests de v√©rification de la coh√©rence entre les offres cl√¥tur√©es en BDD 
et leur disponibilit√© sur l'API France Travail
"""
import asyncio
import pytest
import sys
import os
from datetime import datetime, timedelta
from typing import List, Dict, Any

# Ajouter le r√©pertoire parent au chemin Python
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

from backend.clients.france_travail import FranceTravailAPIClient
from backend.database.connection import DatabaseConnection
from backend.database.repositories.offres import OffresRepository


class TestCoherenceOffresCloturees:
    """Tests de coh√©rence entre BDD et API pour les offres cl√¥tur√©es"""

    @pytest.fixture(autouse=True)
    async def setup(self):
        """Setup pour chaque test"""
        self.db_conn = DatabaseConnection()
        await self.db_conn.connect()
        self.offres_repo = OffresRepository(self.db_conn.async_db)
        self.api_client = FranceTravailAPIClient()
        
        yield
        
        # Cleanup
        self.api_client.close()
        await self.db_conn.close()

    async def test_offres_cloturees_non_disponibles_api(self):
        """
        Test principal: V√©rifie que les offres cl√¥tur√©es en BDD 
        ne sont plus disponibles sur l'API France Travail
        """
        # 1. R√©cup√©rer les offres cl√¥tur√©es de la BDD (√©chantillon r√©cent)
        offres_cloturees = await self._get_offres_cloturees_echantillon()
        
        if not offres_cloturees:
            pytest.skip("Aucune offre cl√¥tur√©e trouv√©e en BDD pour le test")
        
        print(f"\nüîç Test de coh√©rence sur {len(offres_cloturees)} offres cl√¥tur√©es")
        
        # 2. R√©cup√©rer toutes les offres actives depuis l'API
        offres_api_actives = self._get_offres_api_actives()
        source_ids_api = {str(offre.get("id", "")) for offre in offres_api_actives}
        
        print(f"üìä {len(offres_api_actives)} offres actives trouv√©es sur l'API")
        
        # 3. V√©rifier la coh√©rence
        erreurs_coherence = []
        offres_coherentes = 0
        
        for offre_cloturee in offres_cloturees:
            source_id = offre_cloturee["source_id"]
            date_cloture = offre_cloturee.get("date_cloture")
            
            if source_id in source_ids_api:
                # PROBL√àME: Offre cl√¥tur√©e en BDD mais encore active sur l'API
                erreurs_coherence.append({
                    "source_id": source_id,
                    "probleme": "Offre cl√¥tur√©e en BDD mais encore active sur API",
                    "date_cloture_bdd": date_cloture,
                    "intitule": offre_cloturee.get("intitule", "N/A")
                })
            else:
                # OK: Offre cl√¥tur√©e en BDD et bien absente de l'API
                offres_coherentes += 1
        
        # 4. Affichage des r√©sultats
        self._afficher_resultats_coherence(
            len(offres_cloturees), 
            offres_coherentes, 
            erreurs_coherence
        )
        
        # 5. Assertions de test
        taux_coherence = (offres_coherentes / len(offres_cloturees)) * 100
        
        # Le test passe si au moins 95% des offres sont coh√©rentes
        assert taux_coherence >= 95.0, (
            f"Taux de coh√©rence insuffisant: {taux_coherence:.1f}% "
            f"(minimum requis: 95.0%). "
            f"{len(erreurs_coherence)} offres incoh√©rentes d√©tect√©es."
        )
        
        print(f"‚úÖ Test de coh√©rence r√©ussi: {taux_coherence:.1f}% des offres sont coh√©rentes")

    async def test_detection_nouvelles_clotures(self):
        """
        Test de d√©tection: Identifie les offres qui devraient √™tre cl√¥tur√©es
        (pr√©sentes en BDD mais absentes de l'API)
        """
        # 1. R√©cup√©rer toutes les offres actives de la BDD
        offres_bdd_actives = await self._get_offres_bdd_actives()
        
        if not offres_bdd_actives:
            pytest.skip("Aucune offre active trouv√©e en BDD pour le test")
        
        print(f"\nüîç D√©tection de nouvelles cl√¥tures sur {len(offres_bdd_actives)} offres BDD")
        
        # 2. R√©cup√©rer les offres actives depuis l'API
        offres_api_actives = self._get_offres_api_actives()
        source_ids_api = {str(offre.get("id", "")) for offre in offres_api_actives}
        
        # 3. Identifier les offres √† cl√¥turer
        offres_a_cloturer = []
        for offre_bdd in offres_bdd_actives:
            source_id = offre_bdd["source_id"]
            if source_id not in source_ids_api:
                offres_a_cloturer.append({
                    "source_id": source_id,
                    "intitule": offre_bdd.get("intitule", "N/A"),
                    "date_collecte": offre_bdd.get("date_collecte"),
                    "entreprise": offre_bdd.get("entreprise", {}).get("nom", "N/A")
                })
        
        # 4. Affichage des r√©sultats
        print(f"üìä {len(offres_a_cloturer)} offres devraient √™tre cl√¥tur√©es")
        
        if offres_a_cloturer:
            print(f"\nüìù Exemples d'offres √† cl√¥turer:")
            for i, offre in enumerate(offres_a_cloturer[:5], 1):
                print(f"   {i}. {offre['source_id']} - {offre['intitule'][:50]}...")
        
        # 5. Test: Le nombre d'offres √† cl√¥turer doit √™tre raisonnable
        taux_a_cloturer = (len(offres_a_cloturer) / len(offres_bdd_actives)) * 100
        
        # Diagnostic du taux de cl√¥tures n√©cessaires
        if taux_a_cloturer > 80.0:
            print(f"\n‚ö†Ô∏è  ATTENTION: {taux_a_cloturer:.1f}% des offres devraient √™tre cl√¥tur√©es.")
            print("   Cela indique probablement que les offres en base sont anciennes")
            print("   et n'ont pas √©t√© synchronis√©es r√©cemment avec l'API.")
            print("   Recommandation: Ex√©cuter une collecte compl√®te pour mettre √† jour la base.")
        elif taux_a_cloturer > 50.0:
            print(f"\nüìà {taux_a_cloturer:.1f}% des offres devraient √™tre cl√¥tur√©es (normal pour des donn√©es anciennes).")
            print("   Les offres d'emploi ont une dur√©e de vie limit√©e (1-2 mois en g√©n√©ral).")
        elif taux_a_cloturer > 20.0:
            print(f"\nüìä {taux_a_cloturer:.1f}% des offres devraient √™tre cl√¥tur√©es (taux mod√©r√©).")
        else:
            print(f"\n‚úÖ Taux de nouvelles cl√¥tures faible: {taux_a_cloturer:.1f}% (base r√©cente)")
        
        # Seuil tr√®s permissif pour diagnostic (moins de 90% pour √©viter √©chec total)
        assert taux_a_cloturer < 90.0, (
            f"Taux critique d'offres √† cl√¥turer: {taux_a_cloturer:.1f}% "
            f"({len(offres_a_cloturer)}/{len(offres_bdd_actives)}). "
            f"Base de donn√©es compl√®tement d√©synchronis√©e."
        )
        
        print(f"‚úÖ Test de d√©tection r√©ussi: {taux_a_cloturer:.1f}% d'offres √† cl√¥turer (< 90%)")

    async def test_verification_cloture_automatique(self):
        """
        Test de v√©rification: V√©rifie que le syst√®me de cl√¥ture automatique 
        fonctionne lors de la collecte
        """
        from backend.pipelines.sources.france_travail_collector import FranceTravailCollector
        
        print(f"\nü§ñ Test de la cl√¥ture automatique du collector")
        
        # 1. Cr√©er un collector pour test
        collector = FranceTravailCollector("M1805")
        collector.offres_repo = self.offres_repo
        
        # 2. Simuler les donn√©es avant cl√¥ture
        avant_test = await self._compter_offres_actives()
        print(f"üìä Avant test: {avant_test} offres actives en BDD")
        
        # 3. R√©cup√©rer un √©chantillon des donn√©es API
        raw_jobs = self.api_client.collecter_offres_par_code_rome("M1805", max_offres=50)
        source_ids_api = {str(job.get("id", "")) for job in raw_jobs}
        
        # 4. Identifier et cl√¥turer les offres absentes de l'API
        offres_actives = await self.offres_repo.get_active_offers_by_source("france_travail")
        source_ids_actifs = {offre["source_id"] for offre in offres_actives}
        source_ids_a_cloturer = source_ids_actifs - source_ids_api
        
        if source_ids_a_cloturer:
            nb_cloturees = await self.offres_repo.close_offers(list(source_ids_a_cloturer))
            print(f"üîí {nb_cloturees} offres cl√¥tur√©es automatiquement")
        else:
            print(f"‚ÑπÔ∏è Aucune offre √† cl√¥turer d√©tect√©e")
        
        # 5. V√©rifier apr√®s cl√¥ture
        apres_test = await self._compter_offres_actives()
        print(f"üìä Apr√®s test: {apres_test} offres actives en BDD")
        
        # 6. Test: Le nombre d'offres actives doit diminuer ou rester stable
        assert apres_test <= avant_test, (
            f"Le nombre d'offres actives a augment√©: {avant_test} -> {apres_test}. "
            f"Cela ne devrait pas arriver lors d'une cl√¥ture automatique."
        )
        
        if avant_test > apres_test:
            nb_fermees = avant_test - apres_test
            print(f"‚úÖ Cl√¥ture automatique r√©ussie: {nb_fermees} offres cl√¥tur√©es")
        else:
            print(f"‚úÖ Aucune cl√¥ture n√©cessaire, syst√®me coh√©rent")

    # === M√âTHODES UTILITAIRES ===

    async def _get_offres_cloturees_echantillon(self, limite: int = 100) -> List[Dict[str, Any]]:
        """R√©cup√®re un √©chantillon d'offres cl√¥tur√©es r√©centes"""
        pipeline = [
            {
                "$match": {
                    "source": "france_travail",
                    "date_cloture": {"$exists": True, "$ne": None}
                }
            },
            {
                "$sort": {"date_cloture": -1}
            },
            {
                "$limit": limite
            },
            {
                "$project": {
                    "source_id": 1,
                    "intitule": 1,
                    "date_cloture": 1,
                    "date_collecte": 1
                }
            }
        ]
        
        cursor = self.offres_repo.collection.aggregate(pipeline)
        return await cursor.to_list(None)

    async def _get_offres_bdd_actives(self, limite: int = 500) -> List[Dict[str, Any]]:
        """R√©cup√®re un √©chantillon d'offres actives de la BDD"""
        pipeline = [
            {
                "$match": {
                    "source": "france_travail",
                    "$or": [
                        {"date_cloture": {"$exists": False}},
                        {"date_cloture": None}
                    ]
                }
            },
            {
                "$sort": {"date_collecte": -1}
            },
            {
                "$limit": limite
            },
            {
                "$project": {
                    "source_id": 1,
                    "intitule": 1,
                    "date_collecte": 1,
                    "entreprise.nom": 1
                }
            }
        ]
        
        cursor = self.offres_repo.collection.aggregate(pipeline)
        return await cursor.to_list(None)

    def _get_offres_api_actives(self, max_offres: int = None) -> List[Dict[str, Any]]:
        """R√©cup√®re TOUTES les offres actives depuis l'API"""
        try:
            return self.api_client.collecter_offres_par_code_rome(
                "M1805", 
                max_offres=max_offres  # None = pas de limite, r√©cup√®re tout
            )
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur r√©cup√©ration API: {e}")
            return []

    async def _compter_offres_actives(self) -> int:
        """Compte le nombre d'offres actives en BDD"""
        return await self.offres_repo.collection.count_documents({
            "source": "france_travail",
            "$or": [
                {"date_cloture": {"$exists": False}},
                {"date_cloture": None}
            ]
        })

    def _afficher_resultats_coherence(
        self, 
        total_cloturees: int, 
        coherentes: int, 
        erreurs: List[Dict[str, Any]]
    ):
        """Affiche les r√©sultats du test de coh√©rence"""
        taux_coherence = (coherentes / total_cloturees) * 100
        
        print(f"\nüìä R√âSULTATS DU TEST DE COH√âRENCE:")
        print(f"   ‚Ä¢ Total offres cl√¥tur√©es test√©es: {total_cloturees}")
        print(f"   ‚Ä¢ Offres coh√©rentes: {coherentes}")
        print(f"   ‚Ä¢ Offres incoh√©rentes: {len(erreurs)}")
        print(f"   ‚Ä¢ Taux de coh√©rence: {taux_coherence:.1f}%")
        
        if erreurs:
            print(f"\n‚ùå INCOH√âRENCES D√âTECT√âES:")
            for i, erreur in enumerate(erreurs[:5], 1):
                print(f"   {i}. {erreur['source_id']} - {erreur['intitule'][:40]}...")
                print(f"      Probl√®me: {erreur['probleme']}")
            
            if len(erreurs) > 5:
                print(f"   ... et {len(erreurs) - 5} autres incoh√©rences")


# === TESTS UTILITAIRES ===

@pytest.mark.asyncio
async def test_connexion_api_france_travail():
    """Test de base: V√©rification de la connexion API"""
    client = FranceTravailAPIClient()
    
    try:
        # Test simple de r√©cup√©ration d'offres
        offres = client.collecter_offres_par_code_rome("M1805", max_offres=5)
        
        assert len(offres) > 0, "L'API devrait retourner au moins quelques offres"
        assert all("id" in offre for offre in offres), "Chaque offre devrait avoir un ID"
        
        print(f"‚úÖ Connexion API r√©ussie: {len(offres)} offres r√©cup√©r√©es")
        
    finally:
        client.close()


@pytest.mark.asyncio 
async def test_connexion_mongodb():
    """Test de base: V√©rification de la connexion MongoDB"""
    db_conn = DatabaseConnection()
    
    try:
        await db_conn.connect()
        offres_repo = OffresRepository(db_conn.async_db)
        
        # Compter les offres
        nb_offres = await offres_repo.collection.count_documents({"source": "france_travail"})
        
        assert nb_offres >= 0, "Le nombre d'offres devrait √™tre positif ou nul"
        
        print(f"‚úÖ Connexion MongoDB r√©ussie: {nb_offres} offres en BDD")
        
    finally:
        await db_conn.close()


if __name__ == "__main__":
    # Ex√©cution directe pour tests manuels
    async def run_manual_test():
        test_instance = TestCoherenceOffresCloturees()
        
        # Setup manuel (sans fixture pytest)
        test_instance.db_conn = DatabaseConnection()
        await test_instance.db_conn.connect()
        test_instance.offres_repo = OffresRepository(test_instance.db_conn.async_db)
        test_instance.api_client = FranceTravailAPIClient()
        
        try:
            print("üß™ TESTS DE COH√âRENCE OFFRES CL√îTUR√âES")
            print("=" * 50)
            
            # Temporairement, testons seulement la d√©tection de nouvelles cl√¥tures
            # await test_instance.test_offres_cloturees_non_disponibles_api()
            await test_instance.test_detection_nouvelles_clotures()
            # await test_instance.test_verification_cloture_automatique()
            
            print(f"\nüéâ Test de d√©tection termin√© !")
            
        except Exception as e:
            print(f"\n‚ùå Test √©chou√©: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # Cleanup manuel
            test_instance.api_client.close()
            await test_instance.db_conn.close()
    
    asyncio.run(run_manual_test())